package se

import chisel3._
import chisel3.util._
import aes._
import se.seoperation._
import chisel3.util.random._

class SEInput(val canChangeKey: Boolean) extends Bundle{
	val inst = Input(UInt(8.W)) // Instruction encoding is defined in SEOperation/Instructions.scala

	val op1 = Input(UInt(316.W)) // 60bit hash + 256 bit ciphertext

	val op2 = Input(UInt(316.W))

	val valid = Input(Bool())
	val ready = Output(Bool())

	val changeKey_en = if(canChangeKey) Some(Input(Bool())) else None
	val newKey = if(canChangeKey) Some(Input(Vec(11, Vec(16, UInt(8.W))))) else None
}


class SEOutput extends Bundle{
	val result 				= Output(UInt(316.W))
	val valid 				= Output(Bool())
	val ready 				= Input(Bool())
	val op1_compare 		= Output(Bool())
	val op2_compare 		= Output(Bool())
	val op1_compare_valid 	= Output(Bool())
	val op2_compare_valid 	= Output(Bool())
}

class SEIO(val canChangeKey: Boolean) extends Bundle{
	val in = new SEInput(canChangeKey)
	val out = new SEOutput
}

class Plaintext_Reverse_Connector extends Module {
	// Connect 2 reversed 60-bit hash plaintext and 1 8-bit inst together
	val io = IO(new Bundle{
		val op1 	= Input(UInt(316.W))
		val op2 	= Input(UInt(316.W))
		val inst 	= Input(UInt(8.W))
		val out     = Output(Vec(Params.StateLength, UInt(8.W)))
	})
	val op1_hash 		= io.op1(315, 256)
	val op2_hash 		= io.op2(315, 256)
	val connect_result 	= Cat(op1_hash, op2_hash, io.inst)
	// Reverse the byte order so we can convert them into uint with Chisel infrastructure.
	// Here new_integrity_length = (60 + 60 + 8) / 8 = 16
	val connect_result_reverse = Wire(Vec(Params.new_integrity_length, UInt(8.W)))
	for(i <- 0 until Params.new_integrity_length){
		connect_result_reverse(i) := connect_result(Params.new_integrity_length - i - 1)
	}
	// Connect the module output
	io.out := connect_result_reverse
}

class SE(val debug:Boolean, val canChangeKey: Boolean) extends Module{
	// Define the input, output ports and the control bits
	val io = IO(new SEIO(canChangeKey))
	val rolled = true

	/*
	seoperation: the module to actually compute on decrypted plaintexts
	key: preset expanded AES ROM key
	*/
  
	val aes_invcipher = Module(new AESDecrypt(rolled, 1))

	val aes_cipher = Module(new AESEncrypt(rolled))

	val aes_cipher_reverse = Module(new AESEncrypt(rolled))


    io.in.ready := true.B

	val key = Reg(Vec(11, Vec(16,UInt(8.W))))

	val ciphers = Reg(Vec(32, UInt(128.W)))
	val cache_valid = Reg(Vec(32, Bool()))
	val plaintexts = Reg(Vec(32, UInt(64.W)))
	val ptr = RegInit(0.U(8.W))
	val expandedKey128 = VecInit(
    VecInit(0x00.U(8.W), 0x01.U(8.W), 0x02.U(8.W), 0x03.U(8.W), 0x04.U(8.W), 0x05.U(8.W), 0x06.U(8.W), 0x07.U(8.W), 0x08.U(8.W), 0x09.U(8.W), 0x0a.U(8.W), 0x0b.U(8.W), 0x0c.U(8.W), 0x0d.U(8.W), 0x0e.U(8.W), 0x0f.U(8.W)),
    VecInit(0xd6.U(8.W), 0xaa.U(8.W), 0x74.U(8.W), 0xfd.U(8.W), 0xd2.U(8.W), 0xaf.U(8.W), 0x72.U(8.W), 0xfa.U(8.W), 0xda.U(8.W), 0xa6.U(8.W), 0x78.U(8.W), 0xf1.U(8.W), 0xd6.U(8.W), 0xab.U(8.W), 0x76.U(8.W), 0xfe.U(8.W)),
    VecInit(0xb6.U(8.W), 0x92.U(8.W), 0xcf.U(8.W), 0x0b.U(8.W), 0x64.U(8.W), 0x3d.U(8.W), 0xbd.U(8.W), 0xf1.U(8.W), 0xbe.U(8.W), 0x9b.U(8.W), 0xc5.U(8.W), 0x00.U(8.W), 0x68.U(8.W), 0x30.U(8.W), 0xb3.U(8.W), 0xfe.U(8.W)),
    VecInit(0xb6.U(8.W), 0xff.U(8.W), 0x74.U(8.W), 0x4e.U(8.W), 0xd2.U(8.W), 0xc2.U(8.W), 0xc9.U(8.W), 0xbf.U(8.W), 0x6c.U(8.W), 0x59.U(8.W), 0x0c.U(8.W), 0xbf.U(8.W), 0x04.U(8.W), 0x69.U(8.W), 0xbf.U(8.W), 0x41.U(8.W)),
    VecInit(0x47.U(8.W), 0xf7.U(8.W), 0xf7.U(8.W), 0xbc.U(8.W), 0x95.U(8.W), 0x35.U(8.W), 0x3e.U(8.W), 0x03.U(8.W), 0xf9.U(8.W), 0x6c.U(8.W), 0x32.U(8.W), 0xbc.U(8.W), 0xfd.U(8.W), 0x05.U(8.W), 0x8d.U(8.W), 0xfd.U(8.W)),
    VecInit(0x3c.U(8.W), 0xaa.U(8.W), 0xa3.U(8.W), 0xe8.U(8.W), 0xa9.U(8.W), 0x9f.U(8.W), 0x9d.U(8.W), 0xeb.U(8.W), 0x50.U(8.W), 0xf3.U(8.W), 0xaf.U(8.W), 0x57.U(8.W), 0xad.U(8.W), 0xf6.U(8.W), 0x22.U(8.W), 0xaa.U(8.W)),
    VecInit(0x5e.U(8.W), 0x39.U(8.W), 0x0f.U(8.W), 0x7d.U(8.W), 0xf7.U(8.W), 0xa6.U(8.W), 0x92.U(8.W), 0x96.U(8.W), 0xa7.U(8.W), 0x55.U(8.W), 0x3d.U(8.W), 0xc1.U(8.W), 0x0a.U(8.W), 0xa3.U(8.W), 0x1f.U(8.W), 0x6b.U(8.W)),
    VecInit(0x14.U(8.W), 0xf9.U(8.W), 0x70.U(8.W), 0x1a.U(8.W), 0xe3.U(8.W), 0x5f.U(8.W), 0xe2.U(8.W), 0x8c.U(8.W), 0x44.U(8.W), 0x0a.U(8.W), 0xdf.U(8.W), 0x4d.U(8.W), 0x4e.U(8.W), 0xa9.U(8.W), 0xc0.U(8.W), 0x26.U(8.W)),
    VecInit(0x47.U(8.W), 0x43.U(8.W), 0x87.U(8.W), 0x35.U(8.W), 0xa4.U(8.W), 0x1c.U(8.W), 0x65.U(8.W), 0xb9.U(8.W), 0xe0.U(8.W), 0x16.U(8.W), 0xba.U(8.W), 0xf4.U(8.W), 0xae.U(8.W), 0xbf.U(8.W), 0x7a.U(8.W), 0xd2.U(8.W)),
    VecInit(0x54.U(8.W), 0x99.U(8.W), 0x32.U(8.W), 0xd1.U(8.W), 0xf0.U(8.W), 0x85.U(8.W), 0x57.U(8.W), 0x68.U(8.W), 0x10.U(8.W), 0x93.U(8.W), 0xed.U(8.W), 0x9c.U(8.W), 0xbe.U(8.W), 0x2c.U(8.W), 0x97.U(8.W), 0x4e.U(8.W)),
    VecInit(0x13.U(8.W), 0x11.U(8.W), 0x1d.U(8.W), 0x7f.U(8.W), 0xe3.U(8.W), 0x94.U(8.W), 0x4a.U(8.W), 0x17.U(8.W), 0xf3.U(8.W), 0x07.U(8.W), 0xa7.U(8.W), 0x8b.U(8.W), 0x4d.U(8.W), 0x2b.U(8.W), 0x30.U(8.W), 0xc5.U(8.W)))
	
	if(canChangeKey){
		when(reset.asBool){
			key := expandedKey128
		}.elsewhen(io.in.changeKey_en.get){
			key := io.in.newKey.get
		}
	}else{
		when(reset.asBool){
			key := expandedKey128
		}
	}

    val tmp = Wire(Vec(Params.StateLength, UInt(8.W)))
    tmp := VecInit(Seq(
    0x0f.U, 0xf6.U, 0xe5.U, 0xa8.U, 
    0xe8.U, 0x3f.U, 0x2e.U, 0xaa.U, 
    0x9b.U, 0x75.U, 0x0b.U, 0x68.U, 
    0x04.U, 0x6f.U, 0x1c.U, 0xc5.U
  ))
    
    val tmp2 = Wire(Vec(Params.StateLength, UInt(8.W)))
    tmp2 := VecInit(Seq(
    0x0c.U, 0x1c.U, 0xa7.U, 0x76.U, 
    0xab.U, 0x19.U, 0x4b.U, 0x70.U, 
    0x3e.U, 0xee.U, 0xf2.U, 0x9a.U, 
    0x45.U, 0xfa.U, 0x99.U, 0x99.U
  ))

	// Reverse the Vec by byte
  	val reversedTmp = Wire(Vec(Params.StateLength, UInt(8.W)))
  	reversedTmp := VecInit(tmp.reverse)
  	val reversedTmp2 = Wire(Vec(Params.StateLength, UInt(8.W)))
  	reversedTmp2 := VecInit(tmp2.reverse)

	aes_cipher.io.input_text 		:= tmp2
	aes_cipher.io.input_valid 		:= true.B
	aes_cipher.io.input_roundKeys 	:= key

	aes_cipher_reverse.io.input_text 		:= reversedTmp2
	aes_cipher_reverse.io.input_valid 		:= true.B
	aes_cipher_reverse.io.input_roundKeys 	:= key

	aes_invcipher.io.input_op1 := reversedTmp//aes_cipher.io.output_text
	aes_invcipher.io.input_op2 := tmp
    aes_invcipher.io.input_roundKeys := key
	aes_invcipher.io.input_valid := true.B

	when(aes_invcipher.io.output_valid){
		// printf("input of invcipher: %x\n", Cat(aes_invcipher.io.input_op1))
		// printf("output of invcipher: %x\n", Cat(aes_invcipher.io.output_op1))
		printf("input of invcipher op2: %x\n", Cat(aes_invcipher.io.input_op2))
		printf("output of invcipher op2: %x\n", Cat(aes_invcipher.io.output_op2))
    }

    when(aes_cipher.io.output_valid){
        printf("input of cipher: %x\n", Cat(aes_cipher.io.input_text))
		printf("output of cipher: %x\n", Cat(aes_cipher.io.output_text))
	}

	// when(aes_cipher_reverse.io.output_valid){
    //     printf("input of cipher_reverse: %x\n", Cat(aes_cipher_reverse.io.input_text))
	// 	printf("output of cipher_reverse: %x\n", Cat(aes_cipher_reverse.io.output_text))
	// }

	io.out.valid 				:= aes_invcipher.io.output_valid && aes_cipher.io.output_valid && aes_cipher_reverse.io.output_valid
	io.out.result 				:= true.B
	io.out.op1_compare 			:= true.B
	io.out.op2_compare 			:= true.B
	io.out.op1_compare_valid 	:= true.B
	io.out.op2_compare_valid 	:= true.B
}
